# Стандарты кодирования AquaStream

Этот документ описывает соглашения по стилю кодирования, которых следует придерживаться при разработке проекта AquaStream.

## Общие принципы

1. **Читаемость превыше всего**: Пишите код так, чтобы его было легко читать и понимать.
2. **Согласованность**: Следуйте единому стилю во всем проекте.
3. **DRY (Don't Repeat Yourself)**: Избегайте дублирования кода.
4. **KISS (Keep It Simple, Stupid)**: Пишите простой и понятный код.
5. **YAGNI (You Aren't Gonna Need It)**: Не добавляйте функциональность, пока она действительно не нужна.

## Форматирование кода

1. **Отступы**: Используйте 2 пробела для отступов.
2. **Максимальная длина строки**: 100 символов.
3. **Кавычки**: Используйте одинарные кавычки (`'`) для строк.
4. **Точка с запятой**: Всегда используйте точку с запятой.
5. **Фигурные скобки**: Открывающая скобка на той же строке, что и инструкция.
6. **Пробелы**:
   - Внутри фигурных скобок: `{ ключ: значение }`
   - После запятых: `[1, 2, 3]`
   - Вокруг операторов: `a + b`
7. **Пустые строки**: Используйте для логического разделения блоков кода.

## Именование

1. **Компоненты**:
   - PascalCase для имен компонентов: `Button`, `TextField`
   - Если компонент состоит из нескольких слов, соединяйте их: `UserProfile`

2. **Переменные и функции**:
   - camelCase для имен переменных и функций: `userName`, `handleClick`
   - Используйте глаголы для функций: `getData`, `validateForm`
   - Используйте существительные для переменных: `user`, `count`
   - Булевы переменные начинайте с `is`, `has`, `should`: `isLoading`, `hasError`

3. **Константы**:
   - UPPER_SNAKE_CASE для констант: `MAX_ITEMS`, `API_URL`

4. **Приватные свойства и методы**:
   - Начинайте с подчеркивания: `_privateMethod`, `_privateProperty`

5. **Типы и интерфейсы TypeScript**:
   - PascalCase и префикс `I` для интерфейсов: `IUser`, `IApiResponse`
   - PascalCase для типов: `UserType`, `ApiResponseType`

## Структура файлов и импорты

1. **Порядок импортов**:
   ```typescript
   // 1. React и сторонние библиотеки
   import React, { useEffect, useState } from 'react';
   import { useSelector, useDispatch } from 'react-redux';
   
   // 2. UI-компоненты
   import { Button, TextField } from '@/components/ui';
   
   // 3. Утилиты, хуки и сервисы
   import { formatDate } from '@/utils';
   import { useLocalStorage } from '@/hooks';
   import { fetchData } from '@/services/api';
   
   // 4. Стили, типы, константы
   import { UserType } from '@/types';
   import { ITEMS_PER_PAGE } from '@/constants';
   import './styles.css';
   ```

2. **Структура компонента**:
   ```typescript
   // 1. Импорты
   import React from 'react';
   
   // 2. Типы пропсов
   interface ButtonProps {
     variant?: 'primary' | 'secondary';
     onClick?: () => void;
     children: React.ReactNode;
   }
   
   // 3. Определение компонента
   const Button: React.FC<ButtonProps> = ({ variant = 'primary', onClick, children }) => {
     // 4. Хуки и локальное состояние
     const [isHovered, setIsHovered] = useState(false);
     
     // 5. Обработчики событий
     const handleMouseEnter = () => {
       setIsHovered(true);
     };
     
     // 6. Дополнительные вычисления
     const buttonClasses = variant === 'primary' 
       ? 'bg-blue-500 text-white' 
       : 'bg-gray-200 text-gray-800';
     
     // 7. Рендеринг
     return (
       <button 
         className={buttonClasses}
         onClick={onClick}
         onMouseEnter={handleMouseEnter}
       >
         {children}
       </button>
     );
   };
   
   // 8. Экспорт
   export default Button;
   ```

## React и TypeScript

1. **Типизация пропсов**:
   ```typescript
   interface Props {
     label: string;
     value: string;
     onChange: (value: string) => void;
     optional?: boolean;
   }
   
   const TextField: React.FC<Props> = ({ label, value, onChange, optional = false }) => {
     // ...
   };
   ```

2. **Типизация событий**:
   ```typescript
   const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     onChange(e.target.value);
   };
   ```

3. **Дженерики**:
   ```typescript
   function useFetch<T>(url: string): { data: T | null; loading: boolean } {
     // ...
   }
   ```

4. **Типизация состояния**:
   ```typescript
   const [users, setUsers] = useState<User[]>([]);
   ```

## Redux и управление состоянием

1. **Имена действий**:
   - Используйте `domain/action` формат: `users/addUser`, `auth/login`

2. **Срезы**:
   - Организуйте код по функциональным срезам: `userSlice`, `authSlice`
   - Каждый срез в отдельном файле

3. **Селекторы**:
   - Префикс `select`: `selectUsers`, `selectCurrentUser`
   - Мемоизируйте сложные селекторы с помощью `createSelector`

4. **Асинхронные действия**:
   - Используйте `createAsyncThunk` для асинхронных действий
   - Обрабатывайте все состояния: `pending`, `fulfilled`, `rejected`

## Компоненты UI

1. **Пропсы**:
   - Всегда определяйте типы для пропсов
   - Указывайте значения по умолчанию для необязательных пропсов
   - Деструктурируйте пропсы при получении

2. **Состояние**:
   - Используйте локальное состояние для UI-логики
   - Выносите бизнес-логику в хуки или Redux

3. **Ключи в списках**:
   - Всегда указывайте уникальные ключи при рендеринге списков
   - Используйте ID элементов, не индексы массива (когда возможно)

4. **Обработка ошибок**:
   - Используйте Error Boundaries для отлова ошибок в компонентах
   - Предоставляйте информативные сообщения об ошибках

## Тестирование

1. **Именование тестов**:
   - Используйте ясные и описательные имена для тестов
   - Придерживайтесь формата `it('should do something')`

2. **Структура тестов**:
   - Группируйте связанные тесты в блоки `describe`
   - Используйте `beforeEach` для общей настройки

3. **Проверки**:
   - Пишите точные проверки, тестирующие одну функциональность
   - Используйте соответствующие методы проверки

## Комментарии

1. **Когда комментировать**:
   - Комментируйте сложные алгоритмы
   - Объясняйте неочевидные решения
   - Документируйте публичные API

2. **JSDoc**:
   - Используйте JSDoc для документирования функций:
     ```typescript
     /**
      * Форматирует дату в локализованную строку.
      * @param {Date} date - Дата для форматирования
      * @param {string} locale - Код локали (по умолчанию 'ru-RU')
      * @returns {string} Отформатированная строка даты
      */
     function formatDate(date: Date, locale = 'ru-RU'): string {
       // ...
     }
     ```

3. **TODO и FIXME**:
   - Используйте `// TODO:` для обозначения будущих улучшений
   - Используйте `// FIXME:` для обозначения проблем, требующих исправления

## Tailwind CSS

1. **Порядок классов**:
   - Группируйте классы по категориям: позиционирование, размеры, цвета, типографика
   - Используйте инструменты форматирования, такие как Prettier с Tailwind плагином

2. **Кастомные классы**:
   - Определяйте кастомные классы в `tailwind.config.js`
   - Используйте `@apply` для создания сложных компонентов

3. **Отзывчивый дизайн**:
   - Начинайте с мобильной версии и добавляйте классы для больших экранов
   - Используйте префиксы `sm:`, `md:`, `lg:` для отзывчивых стилей

## Git и контроль версий

1. **Коммиты**:
   - Используйте конвенцию Conventional Commits: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`
   - Пишите ясные и краткие сообщения коммитов

2. **Ветвление**:
   - Используйте GitFlow или аналогичную стратегию ветвления
   - Название ветки должно отражать её содержание: `feature/user-login`, `fix/api-error`

3. **Pull Requests**:
   - Делайте небольшие PR, сфокусированные на одной задаче
   - Добавляйте описание и ссылки на связанные задачи

## Доступность (a11y)

1. **Семантический HTML**:
   - Используйте семантические теги: `<header>`, `<nav>`, `<main>`, `<article>`, `<section>`, `<footer>`
   - Правильно структурируйте заголовки (h1-h6)

2. **ARIA-атрибуты**:
   - Добавляйте атрибуты `aria-label`, `aria-describedby` для нетекстовых элементов
   - Используйте `role` для определения роли элемента

3. **Фокус клавиатуры**:
   - Обеспечьте правильную навигацию с клавиатуры
   - Используйте стили для состояния `:focus`

## Производительность

1. **Мемоизация**:
   - Используйте `React.memo` для предотвращения ненужных рендеров
   - Используйте `useMemo` для кэширования вычислений
   - Используйте `useCallback` для стабильных ссылок на функции

2. **Разделение кода**:
   - Используйте динамические импорты для разделения кода
   - Группируйте код по функциональности

3. **Оптимизация изображений**:
   - Сжимайте и оптимизируйте все изображения
   - Используйте правильные форматы и размеры

## Безопасность

1. **XSS-защита**:
   - Избегайте использования dangerouslySetInnerHTML
   - Экранируйте пользовательский ввод

2. **API-вызовы**:
   - Проверяйте входные данные перед отправкой
   - Правильно обрабатывайте ошибки

3. **Аутентификация**:
   - Правильно обрабатывайте токены и сессии
   - Храните чувствительные данные безопасно 