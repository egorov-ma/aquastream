# Frontend Refactoring Backlog

## 1. Зафиксировать стабильный стек *(выполнено)*
- **Context:** Сейчас используются `next@15`, `react@19`, `tailwindcss@4` — они находятся в pre-release и ведут к нестабильным сборкам и расхождениям UI.
- **Prerequisites:** Решение команды: целимся на "последние стабильные релизы" (Next 14.x, React 18.x, Tailwind 3.4.x) либо остаёмся на canary, но с официальным миграционным планом.
- **Steps:**
  1. Провести аудит зависимостей, подтвердить статус релизов и составить таблицу несовместимостей (например, `tailwindcss-animate` vs Tailwind 3).
  2. На базе решения команды откатить на стабильные версии либо внедрить release-процесс: отдельная ветка для апдейтов, CI с `pnpm build`, e2e smoke, визуальный тест.
  3. Обновить `package.json`, `pnpm-lock.yaml`, конфиги `next.config.ts`, `postcss.config.mjs`, убедиться в корректности плагинов (`@tailwindcss/postcss`, `tailwindcss-animate`).
  4. Прогнать `pnpm lint`, `pnpm typecheck`, `pnpm build`; зафиксировать результат в CHANGELOG/документации.
- **Acceptance Criteria:**
  - Сборка и запуск DevServer проходят без предупреждений.
  - Документ в `docs/frontend/stack.md` описывает выбранный стек и процедуру обновления основных зависимостей.
  - На CI доступны smoke-тесты, подтверждающие работоспособность UI после изменения версий.

## 2. Выровнять шрифты и дизайн-токены *(выполнено)*
- **Context:** В `app/layout.tsx` подключены шрифты Geist, но токены в `app/globals.css` по-прежнему указывают на Inter/JetBrains, что создаёт визуальный разнобой.
- **Prerequisites:** Финальное решение по семействам (Geist или Inter/JetBrains) и fallback-гарнитурам.
- **Steps:**
  1. Обновить `@theme inline` и `:root` в `app/globals.css`, чтобы `--font-sans`, `--font-serif`, `--font-mono` ссылались на выбранную гарнитуру и fallback.
  2. Проверить компоненты (`Button`, `Card`, `Form`, `Typography`) на наличие жёстко прописанных шрифтов; заменить на токены.
  3. Пересобрать проект, проверить devtools и визуально сравнить авторизацию, дашборд и публичные страницы.
- **Acceptance Criteria:**
  - В UI нет смешения гарнитур; переменные шрифта едины во всех компонентах.
  - В `docs/frontend/design-tokens.md` зафиксированы значения шрифтов и правила использования.

## 3. Реализовать Collapsed Sidebar до конца *(выполнено)*
- **Context:** `SidebarProvider` хранит состояние `collapsed`, но верстка не реагирует — кнопка не изменяет UI.
- **Prerequisites:** Мокапы двух состояний (full / compact), поведение на мобильных, требования по доступности.
- **Steps:**
  1. Проработать классы и логику на базе `data-collapsed` для `app/(routes)/org/dashboard/page.tsx` и `AppSidebar`.
  2. Обновить `SidebarTrigger`, добавить aria-атрибуты и hotkey (если требуется).
  3. Написать Playwright-тест, который кликает по триггеру и проверяет DOM и визуальные слоты.
- **Acceptance Criteria:**
  - Триггер переключает панель, класс `data-collapsed` влияет на ширину/контент.
  - Пользуемый сценарий доступен с клавиатуры; фокус не теряется.
  - Тесты проходят и защищают от регрессии.

## 4. Нормализовать layout- и типографические примитивы *(выполнено)*
- **Context:** Страницы используют произвольные наборы Tailwind-классов (`grid gap-4`, `text-xl`), из-за чего компоненты вне shadcn выглядят иначе.
- **Prerequisites:** Каталог повторяющихся шаблонов (PageHeader, Section, Toolbar, EmptyState, Hero и т.д.).
- **Steps:**
  1. Провести аудит layout’ов (главная, авторизация, дашборды, страницы регистрации) и зафиксировать повторяющиеся блоки.
  2. Создать/уточнить универсальные обёртки (например, `Section`, `Stack`, `PageHeader`, `Toolbar`) с использованием токенов (`--spacing`, `--radius`).
  3. Заменить кастомные `div` на эти примитивы, сократив ручные классы до минимума.
  4. Добавить Storybook/MDX-примеры или отдельную страницу-каталог для визуальной проверки.
- **Acceptance Criteria:**
  - Все ключевые страницы строятся из общего набора layout-компонентов.
  - Отступы, типографика и цвета совпадают между маркетинговыми и product-экранами.
  - В проекте нет дублирующих CSS-паттернов для заголовков и секций.

## 5. Убедиться в совместимости `tailwind-merge` *(выполнено)*
- **Context:** Хелпер `cn` опирается на `tailwind-merge`, который пока не знает про часть классов Tailwind 4 (`size-*`, `group-data-*`), что может приводить к потере стилей.
- **Prerequisites:** Узнать roadmap библиотеки и текущую поддержку Tailwind 4.
- **Steps:**
  1. Проверить changelog `tailwind-merge` и наличие поддержки Tailwind 4.x либо инструкций для кастомных конфигов.
  2. Настроить кастомные правила или временно отключить merge в критичных компонентах (`Calendar`, `DropdownMenu`, `NavigationMenu`).
  3. Добавить unit-тест на `cn`, который прогоняет современные классы и убеждается, что они не очищаются.
- **Acceptance Criteria:**
  - Потеря классов исключена; проверено тестом/визуально.
  - В документации (`docs/frontend/stack.md`) отражено, как расширяется tailwind-merge.

## 6. Проверить toolchain на новые CSS-селекторы *(выполнено)*
- **Context:** Используются селекторы `**:data-[slot=...]`, `group-data-[...]` (Tailwind 4). IDE/Prettier/ESLint могут их не понимать.
- **Prerequisites:** Список нестандартных селекторов в проекте.
- **Steps:**
  1. Собрать используемые селекторы командой `rg '\*\*:data'` и `rg 'group-data'`.
  2. Проверить работу ESLint, Prettier, форматтера VS Code; при необходимости обновить плагины.
  3. Описать в документации, какие версии тулов поддерживаются и как обновлять.
- **Acceptance Criteria:**
  - Автоформат и линт проходят без предупреждений.
  - В `docs/frontend/tooling.md` есть секция о поддержке новых селекторов.

## 7. Консолидировать использование shadcn-компонентов *(выполнено)*
- **Context:** Некоторые блоки (например, `SiteHeader`, `States`) сверстаны вручную и визуально отходят от shadcn.
- **Prerequisites:** Каталог всех самописных UI-элементов и их назначение.
- **Steps:**
  1. Проанализировать текущие компоненты и определить, какие можно пересобрать на базе shadcn, какие — оформить как расширения (через `data-slot`).
  2. Внедрить общую систему слотов/вариантов через `cva` для повторяющихся паттернов.
  3. Обновить страницы, чтобы новые версии компонентов использовались повсеместно.
- **Acceptance Criteria:**
  - Для типовых сценариев (формы, таблицы, состояния) есть единые компоненты.
  - Нет дублирующих реализаций одного и того же паттерна в разных местах.

## 8. Создать Frontend Design Playbook (docs-as-code) *(выполнено)*
- **Context:** В корне `docs/` уже ведётся документация; часть устарела, а гайд по сборке UI отсутствует.
- **Prerequisites:** Выполнены/запланированы задачи 2, 4, 7 (есть понимание токенов и примитивов).
- **Steps:**
  1. Ревизовать содержимое `docs/`, удалить/обновить устаревшие записи.
  2. Создать `docs/frontend/design-playbook.md` (или AD/ADR) с разделами: токены, базовые компоненты, layout-примитивы, примеры "как правильно".
  3. В README/внутреннем wiki дать ссылку на playbook; договориться, что PR без следования гайдам разворачивается.
- **Acceptance Criteria:**
  - Документация актуальна, хранится в `docs/` (doc-as-code).
  - Команда использует playbook при разработке и ревью.

## 9. Настроить защиту от визуальных регрессий *(выполнено)*
- **Context:** Основная причина несостыковок — отсутствие автоматических проверок.
- **Prerequisites:** CI/CD с возможностью запускать визуальные тесты (например, Playwright, Storybook + Chromatic, Percy).
- **Steps:**
  1. Выбрать инструмент (Storybook с локальными snapshots, Playwright screenshot, Chromatic) и добавить базовые сценарии (форма авторизации, дашборд, ключевые компоненты).
  2. Настроить запуск в CI и правило, что PR с визуальными отличиями требуют дизайнера/фронтенд-ревью.
  3. Обновить PR-шаблон и checklist командных ревью.
- **Acceptance Criteria:**
  - В CI появляются визуальные проверки; PR блокируется при расхождениях без апрува.
  - Есть инструкция в `docs/frontend/testing.md` по работе с этими проверками.

## 10. Внедрить процесс предотвращения дрейфа
- **Context:** Даже после рефакторинга нужно удерживать консистентность.
- **Prerequisites:** Playbook (Task 8) и визуальные тесты (Task 9).
- **Steps:**
  1. Обновить шаблон PR (/.github/pull_request_template.md) — добавить пункты: "Компонент использует shadcn-примитивы", "Выполнены визуальные тесты", "Документация обновлена".
  2. Создать lint-правила или custom ESLint plugin (минимум — lint rule, запрещающий raw-классы без токенов в определённых папках).
  3. Проводить ежеквартальный UI-аудит: заведите recurring issue в `docs/frontend/process.md`.
- **Acceptance Criteria:**
  - PR checklist обновлён, eslint-правила или линтеры настроены.
  - Существует расписание регулярных аудитов, зафиксированное в документации.
  - После этих шагов новые фичи соответствуют гайдлайнам без ручного контроля.
